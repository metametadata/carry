{
    "docs": [
        {
            "location": "/", 
            "text": "Carry\n\n\nClojureScript single-page application framework inspired by\n\nre-frame\n,\n\nElm architecture\n,\n\nRedux\n and\n\nCerebral\n.\n\n\nThe core of the framework is a simple state management library. \nUI bindings, routing, debugger, etc. are implemented as separate optional packages.\n\n\n\n\nFeatures\n\n\n\n\nFunctional API with no globals makes apps easy to extend and unit test.\n\n\nAgnostic to UI layer.\n\n\nTime traveling debugger inspired by \nRedux DevTools\n and \nCerebral Debugger\n.\n\n\nLive code editing using \nFigwheel\n and debugger's replay mode.\n\n\nReagent\n bindings achieve code readability and rendering optimization\nusing view-model/view pattern based on Reagent reactions (\nsimilarly to re-frame\n).\n\n\nFractality: \nElm-ish architecture\n can be applied to create composite apps.\n\n\n\n\nDesign\n\n\n\n\n\n\nAn app is defined by its initial model value, controller and reconciler.\n\n\nAll app state is stored inside a single model atom.\n\n\nAnyone can read model value at any given time and subscribe to its changes.\n\n\nController function receives signals to perform side effects and dispatch actions.\n\n\nAnyone can dispatch a new signal: controller, views, timers, etc.\n\n\nModel can be modified only by dispatching actions.\n\n\nOnly controller can dispatch actions.\n\n\nReconciler is a pure function which returns a new model value based on an incoming action.\n\n\nWhen UI layer subscribes to model changes we get a unidirectional data flow: UI -\n signal -\n action -\n model -\n UI -\n etc.\n\n\n\n\nExample\n\n\nDemo\n,\n\nSource code\n\n\nCounter spec and UI:\n\n\n(ns counter.core\n  (:require [cljs.core.match :refer-macros [match]])\n  (:require-macros [reagent.ratom :refer [reaction]]))\n\n(def -initial-model {:val 0})\n\n(defn -control\n  [model signal _dispatch-signal dispatch-action]\n  (match signal\n         :on-start nil\n         :on-stop nil\n\n         :on-increment\n         (dispatch-action :increment)\n\n         :on-decrement\n         (dispatch-action :decrement)\n\n         :on-increment-if-odd\n         (when (odd? (:val @model))\n           (dispatch-action :increment))\n\n         :on-increment-async\n         (.setTimeout js/window #(dispatch-action :increment) 1000)))\n\n(defn -reconcile\n  [model action]\n  (match action\n         :increment (update model :val inc)\n         :decrement (update model :val dec)))\n\n(defn view-model\n  [model]\n  {:counter (reaction (str \n#\n (:val @model)))})\n\n(defn view\n  [{:keys [counter] :as _view-model} dispatch]\n  [:p\n   @counter \n \n\n   [:button {:on-click #(dispatch :on-increment)} \n+\n] \n \n\n   [:button {:on-click #(dispatch :on-decrement)} \n-\n] \n \n\n   [:button {:on-click #(dispatch :on-increment-if-odd)} \nIncrement if odd\n] \n \n\n   [:button {:on-click #(dispatch :on-increment-async)} \nIncrement async\n]])\n\n(def spec {:initial-model -initial-model\n           :control       -control\n           :reconcile     -reconcile})\n\n\n\n\nMain file:\n\n\n(ns app.core\n  (:require [counter.core :as counter]\n            [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [reagent.core :as r]))\n\n(let [app (carry/app counter/spec)\n      [_ app-view] (carry-reagent/connect app counter/view-model counter/view)]\n    (r/render app-view (.getElementById js/document \nroot\n))\n    ((:dispatch-signal app) :on-start))\n\n\n\n\nPackages\n\n\nUI Bindings\n\n\n\n\nReagent\n\n\n\n\nMiddleware\n\n\n\n\nDebugger\n\n\nHistory\n\n\nLogging\n\n\nPersistence\n\n\nSchema\n\n\n\n\nDocumentation\n\n\nMore information can be found at \nthe project site\n:\n\n\n\n\nUser Guide\n\n\nExamples\n\n\nAPI Reference\n\n\nDeveloper Guide\n\n\n\n\nLicense\n\n\nCopyright \u00a9 2016 Yuri Govorushchenko.\n\n\nReleased under an MIT license.", 
            "title": "Readme"
        }, 
        {
            "location": "/#carry", 
            "text": "ClojureScript single-page application framework inspired by re-frame , Elm architecture , Redux  and Cerebral .  The core of the framework is a simple state management library. \nUI bindings, routing, debugger, etc. are implemented as separate optional packages.", 
            "title": "Carry"
        }, 
        {
            "location": "/#features", 
            "text": "Functional API with no globals makes apps easy to extend and unit test.  Agnostic to UI layer.  Time traveling debugger inspired by  Redux DevTools  and  Cerebral Debugger .  Live code editing using  Figwheel  and debugger's replay mode.  Reagent  bindings achieve code readability and rendering optimization\nusing view-model/view pattern based on Reagent reactions ( similarly to re-frame ).  Fractality:  Elm-ish architecture  can be applied to create composite apps.", 
            "title": "Features"
        }, 
        {
            "location": "/#design", 
            "text": "An app is defined by its initial model value, controller and reconciler.  All app state is stored inside a single model atom.  Anyone can read model value at any given time and subscribe to its changes.  Controller function receives signals to perform side effects and dispatch actions.  Anyone can dispatch a new signal: controller, views, timers, etc.  Model can be modified only by dispatching actions.  Only controller can dispatch actions.  Reconciler is a pure function which returns a new model value based on an incoming action.  When UI layer subscribes to model changes we get a unidirectional data flow: UI -  signal -  action -  model -  UI -  etc.", 
            "title": "Design"
        }, 
        {
            "location": "/#example", 
            "text": "Demo , Source code  Counter spec and UI:  (ns counter.core\n  (:require [cljs.core.match :refer-macros [match]])\n  (:require-macros [reagent.ratom :refer [reaction]]))\n\n(def -initial-model {:val 0})\n\n(defn -control\n  [model signal _dispatch-signal dispatch-action]\n  (match signal\n         :on-start nil\n         :on-stop nil\n\n         :on-increment\n         (dispatch-action :increment)\n\n         :on-decrement\n         (dispatch-action :decrement)\n\n         :on-increment-if-odd\n         (when (odd? (:val @model))\n           (dispatch-action :increment))\n\n         :on-increment-async\n         (.setTimeout js/window #(dispatch-action :increment) 1000)))\n\n(defn -reconcile\n  [model action]\n  (match action\n         :increment (update model :val inc)\n         :decrement (update model :val dec)))\n\n(defn view-model\n  [model]\n  {:counter (reaction (str  #  (:val @model)))})\n\n(defn view\n  [{:keys [counter] :as _view-model} dispatch]\n  [:p\n   @counter    \n   [:button {:on-click #(dispatch :on-increment)}  + ]    \n   [:button {:on-click #(dispatch :on-decrement)}  - ]    \n   [:button {:on-click #(dispatch :on-increment-if-odd)}  Increment if odd ]    \n   [:button {:on-click #(dispatch :on-increment-async)}  Increment async ]])\n\n(def spec {:initial-model -initial-model\n           :control       -control\n           :reconcile     -reconcile})  Main file:  (ns app.core\n  (:require [counter.core :as counter]\n            [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [reagent.core :as r]))\n\n(let [app (carry/app counter/spec)\n      [_ app-view] (carry-reagent/connect app counter/view-model counter/view)]\n    (r/render app-view (.getElementById js/document  root ))\n    ((:dispatch-signal app) :on-start))", 
            "title": "Example"
        }, 
        {
            "location": "/#packages", 
            "text": "", 
            "title": "Packages"
        }, 
        {
            "location": "/#ui-bindings", 
            "text": "Reagent", 
            "title": "UI Bindings"
        }, 
        {
            "location": "/#middleware", 
            "text": "Debugger  History  Logging  Persistence  Schema", 
            "title": "Middleware"
        }, 
        {
            "location": "/#documentation", 
            "text": "More information can be found at  the project site :   User Guide  Examples  API Reference  Developer Guide", 
            "title": "Documentation"
        }, 
        {
            "location": "/#license", 
            "text": "Copyright \u00a9 2016 Yuri Govorushchenko.  Released under an MIT license.", 
            "title": "License"
        }, 
        {
            "location": "/user-guide/", 
            "text": "Basics\n\n\nThis section explains everything you need to start making apps with Carry. \n\n\nApp\n\n\n\n\nIn a Carry application all the code you write is encapsulated behind a single \napp\n instance. \nAn app is a map with keys:\n\n\n\n\n:model\n - a read-only atom, an in-memory representation of an app state\n\n\n:dispatch-signal\n - a function for interaction with an app, always returns nil\n\n\n\n\nOne can consider an app to be a black box which exposes its current state and modifies it on getting signals from an external world.\nIt can also affect an external world as a response to a signal, i.e. perform \"side effects\".\n\n\nModel\n\n\nModel represents an entire state of an app. \n\n\nOne can access app's model via \n:model\n key to obtain a read-only atom that can be dereferenced and watched, but cannot be mutated:\n\n\n(def my-model (:model app))\n\n@my-model\n;=\n {...}\n\n(add-watch my-model :my-watcher\n           (fn [_key _atom old-state new-state]\n             (when (not= old-state new-state)\n               (println \nmodel value has changed!\n))))\n\n(reset! my-model {:foo :bar})\n;=\n Error: read-only atom cannot be reset to {:foo :bar}\n\n((:dispatch-signal app) some-model-changing-signal)\n;=\n model value has changed!\n\n(remove-watch my-model :my-watcher)\n\n\n\n\nCarry requires a model value to be a map. This convention allows writing reusable packages that can store additional data into any Carry app.\nAs an example, \ncarry-history\n adds \n:token\n to a model.\n\n\nSignals\n\n\nSignal\n is an object which represents a user's intention or, looking at it from a different angle, a system event. \nSignal can be synchronously sent to an app by calling its \ndispatch-signal\n function:\n\n\n((:dispatch-signal my-app) my-signal)\n\n\n\n\nCarry accepts signals of any type. But usually signal is a just keyword with the \"on-\" prefix or\na serializable vector with a keyword and an additional payload:\n\n\n:on-clear-completed\n[:on-update-todo id val]\n[:carry-history.core/on-enter token]\n\n\n\n\nCreating an App\n\n\nIn order to create an instance of a Carry app a user has to pass a \nspec\n into \napp\n function:\n\n\n(let [my-app (carry/app my-spec)]\n  ; ...\n  )\n\n\n\n\nA spec is a map with keys:\n\n\n\n\n:initial-model\n - an initial model value\n\n\n:control\n - a function for handling signals\n\n\n:reconcile\n - a function for handling actions\n\n\n\n\nIn other words, a spec is needed to define a runtime behavior of an app:\n\n\n\n\nControl\n\n\nController (control function, control)\n is a part of an application responsible for handling incoming signals. \nIt can dispatch new signals, modify app model (by dispatching actions) and perform any side effects (e.g. send data to a server).\nController is also free to contain an asynchronous code. The signature of a control function:\n\n\n(defn control\n  [model signal dispatch-signal dispatch-action])\n\n\n\n\n\n\nmodel\n - a read-only atom, the same as app's \n:model\n\n\nsignal\n - an incoming signal \n\n\ndispatch-signal\n - a synchronous function for dispatching new signals, always returns \nnil\n, the same as app's \n:dispatch-signal\n\n\ndispatch-action\n - a synchronous function for modifying a model, always returns \nnil\n\n\nReturn value will not be used\n\n\n\n\nBy convention, control should be able to at least handle \n:on-start\n and \n:on-stop\n signals.\nAs we'll see later, it's required by middleware with setup/teardown logic and to support hot reloading.\n\n\nIt is convenient (but not required) to use \npattern matching\n \nto switch between signals and destructure signals with payload.\nAs an example, this is a controller from \nfriend-list\n demo app:\n\n\n(ns friend-list.core\n  (:require [carry-history.core :as h]\n            ; ...\n            [goog.functions :refer [debounce]]\n            [cljs.core.match :refer-macros [match]]))\n\n; It's recommended to create a factory function if controller uses external dependencies.\n; It makes code more decoupled and \n; easier to unit test (stubs/mocks can be easily used instead of real implementations).\n; In this example browser history manager and API client are external dependencies.\n(defn -new-control\n  [history api-search]\n  ; Some helper functions.\n  ; On successful search a new :on-search-success signal will be dispatched.\n  (let [search (fn [q dispatch-signal] (api-search q #(dispatch-signal [:on-search-success q %])))\n        search-on-input (debounce (fn [q dispatch-signal]\n                                    (h/push-token history q)\n                                    (search q dispatch-signal))\n                                  300)]\n    ; Function name is specified for better stacktraces.\n    (fn control\n      [model signal dispatch-signal dispatch-action]\n      (match signal\n             ; This application has no custom setup/teardown logic\n             ; so just return nil on standard signals:             \n             :on-start nil\n             :on-stop nil\n\n             ; Macro will throw an exception on unknown signals.\n\n             ; Signal destructuring example \n             [:on-input q]\n             (do\n               ; Update model.\n               (dispatch-action [:set-query q])\n\n               ; Begin (possibly async) searching.\n               (search-on-input q dispatch-signal))\n\n             ; ...\n\n             [:on-search-success q friends]\n             ; Note that model has to be dereferenced to get its value.\n             (if (= (:query @model) q)\n               (dispatch-action [:set-friends friends])\n               (println \nignore response for\n (pr-str q)\n                        \nbecause current query is\n (pr-str (:query @model))))))))\n\n; ...\n\n; Dependencies will be injected in a spec factory function:\n(defn new-spec\n  [history api-search]\n  {; ...\n   :control (-new-control history api-search)})\n\n; ...\n\n; Create and start an app using concrete dependencies.\n(def my-app (carry/app (new-spec my-history my-api-client)))\n((:dispatch-signal app) :on-start)\n\n\n\n\nActions\n\n\nAction\n is an object which represents an intention to modify a model.\nActions can be dispatched only from within a control function via \ndispatch-action\n.\n\n\nSimilar to signals, actions are usually keywords or vectors, for instance:\n\n\n:increment\n[:set-query q]\n\n\n\n\nReconcile\n\n\nReconciler (reconcile function, reconcile)\n is a part of an application responsible for handling incoming actions.\nIt's a pure function which returns a new model value based on a current model value and an incoming action.\nOn getting an action an app passes it into a reconciler and then resets app model value with the result.\n\n\nA simple example from \nfriend-list\n demo app:\n\n\n(defn -reconcile\n  [model action]\n  (match action\n         [:set-query q]\n         (assoc model :query q)\n\n         [:set-friends friends]\n         (assoc model :friends friends)))\n\n\n\n\nIt's important to not put any async code, side effects or nondeterministic code (e.g. random number generation)\ninto reconciler. Otherwise, it will make replaying actions unpredictable and break time traveling debugging.\n\n\nUsage with Reagent\n\n\nCarry can work with any view layer that is able to re-render UI in response to app model changes.\nThis chapter is about tying Carry with \nReagent\n \n(a ClojureScript wrapper for \nReact\n)\nusing \ncarry-reagent\n package: \n\n\n(ns app.core\n  (:require [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [reagent.core :as r]))\n\n; ...\n\n; Define app view model and view:\n\n(defn my-view-model\n  [model]\n  ; define a view model...\n)\n\n(defn my-view\n  [view-model dispatch]\n  ; a Reagent component that uses data from a view-model and dispatches signals on events...\n)\n\n(let [; Create an app.\n      app (carry/app my-spec)\n\n      ; \nConnect\n app, view model and view to create a Reagent component.\n      [_ app-view] (carry-reagent/connect app my-view-model my-view)]\n    ; Render component into DOM.\n    (r/render app-view (.getElementById js/document \nroot\n))\n\n    ; ...\n)\n\n\n\n\nApp view is constructed using \ncarry-reagent.core/connect\n function:\n\n\n(connect [app view-model view])\n\n\n\n\n\n\napp\n - Carry app instance\n\n\nview-model\n - a function which produces a view model\n\n\nview\n - a Reagent component\n\n\nReturns a pair \n[view-model-instance view-component]\n (view model is returned mainly for debugging)\n\n\n\n\nview-model\n function is called once on \nconnect\n call.\nThen returned view model instance is passed as an argument into \nview\n function to produce a final view component.\nA view thereby listens to a view model that in turn listens to a model:\n\n\n\n\nIn the next section we'll see how to define a view model.\n\n\nView Model\n\n\nView model\n contains all the data needed to render a UI.\nIt can compute derived model data, split lists of objects into pages, calculate which buttons are enabled, \ndetermine which app page to show depending on current URL, etc.\n\n\nUsually view model is a map of Reagent reactions. An example from \nTodoMVC\n app:\n\n\n(ns app.view-model\n  (:require ; ...\n            [carry-reagent.core :as carry-reagent])\n  (:require-macros [reagent.ratom :refer [reaction]]))\n\n(defn view-model\n  [model]\n  (let [; ...\n        ; Wrap todo items in a reaction.\n        all-todos (reaction (:todos @model))]\n    (-\n model\n        ; This helper function call will return {:field (reaction (:field @model))} map.\n        ; Note: :field contains the value of a new todo input.\n        (carry-reagent/track-keys [:field])\n\n        ; Additional view model fields are reactions \n        ; which will be recalculated if (and only if) all-todos value changes:\n        (assoc :has-todos? (reaction (-\n @all-todos count pos?))\n               :all-completed? (reaction (every? :completed? @all-todos))\n               ; ...\n               ))))\n\n\n\n\nArgument \nmodel\n is a read-only \nReagent atom (ratom)\n that behaves almost exactly as a read-only model atom (i.e. \n(:model app)\n), \nbut can also be used in Reagent components and reactions.\n\n\nReaction\n is a special ratom-like object that is created using Reagent's \nreaction\n macro.\nIt is lazily computed from other ratoms/reactions.\nAny Reagent component that dereferences a reaction is going to be re-rendered when reaction value updates.\n\n\nView\n\n\nAn example from \nTodoMVC\n app:\n\n\n; A plain Reagent component which is redrawn when input arguments change.\n(defn -header\n  [field dispatch]\n  ; Reagent uses Hiccup-like syntax for defining HTML.\n  [:header.header\n   [:h1 \ntodos\n]\n\n   ; Input value is equal to field arg value.\n   [:input.new-todo {:placeholder \nWhat needs to be done?\n\n                     :value       field\n\n                     ; Dispatch signals on input events.\n                     :on-change   #(dispatch [:on-update-field (.. % -target -value)])\n                     :on-key-down #(when (-enter-key? %) (dispatch :on-add))}]])\n\n; Top app component that is passed into connect function.\n(defn view\n  ; Destructure view model map for cleaner code in the function body.\n  [{:keys [field has-todos? all-completed?\n           ; ...\n           ] :as _view-model}\n   dispatch]\n  [:section.todoapp\n   ; Deref |field| reaction to get its value for rendering.\n   ; Derefing also makes parent component start watching for |field| changes \n   ; so that -header will be re-rendered on |field| updates. \n   [-header @field dispatch]\n\n   ; ...\n   ]))\n\n\n\n\nAs you can see, we get reactions from a view model and deref them to render actual values.\nReagent will then \"magically\" re-render components when the reactions passed into them are updated.\n\n\nUsage with Figwheel\n\n\nWith \nFigwheel\n Leiningen plugin it is possible to:\n\n\n\n\ncompile and reload app code in browser on source code changes\n\n\ncommunicate with a running app via REPL\n\n\n\n\nAll the Carry \nexamples\n use Figwheel for development builds and \nrely on the \"bare\" \nlein-cljsbuild\n for production builds.\n\n\nThe main thing to remember is to stop the currently running app before hot reload \nin order to unsubscribe it from browser events and free memory.\nHere's how you can structure your main app file to be used with Figwheel: \n\n\n(ns app.core\n  (:require [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [reagent.core :as r]))\n\n; ...\n\n(defn main\n  []\n  (let [app (carry/app my-spec)\n        [app-view-model app-view] (carry-reagent/connect app my-view-model my-view)]\n    (r/render app-view (.getElementById js/document \nroot\n))\n\n    ; Start the app.\n    ((:dispatch-signal app) :on-start)\n\n    ; For debugging purposes add view-model into returned map.\n    (assoc app :view-model app-view-model)))\n\n; Start new app and save it into the global var for debugging in REPL.\n(def app (main))\n\n;;;;;;;;;;;;;;;;;;;;;;;; Figwheel stuff\n; These functions should be specified in project.clj :figwheel map.\n\n; Stop current app before loading a new one.\n(defn before-jsload\n  []\n  ((:dispatch-signal app) :on-stop))\n\n(defn on-jsload\n  []\n  #_(. js/console clear))\n\n\n\n\nAdvanced\n\n\nMiddleware\n\n\nMiddleware\n is a function that gets an app spec and returns an updated spec\nin order to introduce some new app behavior (such as logging, syncing with server, crash reporting).\n\n\n\n\n Also see: \nready-to-use middleware packages\n.\n\n\n\n\nMultiple middleware can be applied in a chain to produce a new spec.\nFor instance, \nTodoMVC\n app spec is wrapped by three middleware:\n\n\n(defn new-spec\n  [history storage storage-key todo-titles]\n  (-\n {:initial-model (model/new-model todo-titles)\n       :control       control\n       :reconcile     reconcile}\n\n      ; 1\n      (schema/add model/Schema)\n\n      ; 2\n      (persistence/add storage storage-key {:blacklist #{::h/token}})\n\n      ; 3\n      (h/add history)))\n\n\n\n\nAs an example, this is a simple middleware which logs all actions and signals coming through an app:\n\n\n(ns carry-logging.core)\n\n(defn add\n  \nWill print all signals and actions to console.\n\n  ([spec] (add spec \n))\n  ([spec prefix]\n   (-\n spec\n       ; Wrap control to log signals.\n       (update :control (fn wrap-control [control]\n                          (fn logged-control [model signal dispatch-signal dispatch-action]\n                            (try\n                              ; Log.\n                              (.group js/console (str prefix \nsignal \n (pr-str signal)))\n\n                              ; Call original function.\n                              (control model signal dispatch-signal dispatch-action)\n\n                              ; Always close the group.\n                              (finally\n                                (.groupEnd js/console))))))\n\n       ; Wrap reconcile to log actions.\n       (update :reconcile\n               (fn wrap-reconcile [reconcile]\n                 (fn logged-reconcile [model action]\n                   ; Log.\n                   (.log js/console (str prefix \naction\n) (pr-str action))\n\n                   ; Call original function.\n                   (reconcile model action)))))))\n\n\n\n\nMore complex middleware can:\n\n\n\n\nModify initial model.\n\n\nIntercept \n:on-start\n/\n:on-stop\n signals.\n\n\nDispatch new signals and actions to an app.\nBy convention, they must use namespaced keywords (e.g. \n:my-middlware.core/on-something\n) to prevent a name clash with other signals.\n\n\nDispatch own signals and actions which should not be handled by an app. They must also use namespaced keywords.\n\n\nSubscribe to model changes.\n\n\nHave injected dependencies.\n\n\n\n\nAll these cases are demonstrated by \ncarry-history\n middleware:\n\n\n(ns carry-history.core\n  ; ...\n)\n\n(defn -wrap-initial-model\n  [app-initial-model]\n  (merge {::token \n/\n} app-initial-model))\n\n; History will be injected on applying the middleware.\n(defn -wrap-control\n  [app-control history]\n  (let [unlisten (atom nil)]\n    (fn control\n      [model signal dispatch-signal dispatch-action]\n      (match signal\n             ; Intercept :on-start signal.\n             :on-start\n             (do\n               ; Let the wrapped app start first.\n               (app-control model signal dispatch-signal dispatch-action)\n\n               ; Start listening to model updates.\n               (add-watch model ::token-watcher\n                          (fn [_key _atom old-state new-state]\n                            ; ...\n                            ))\n\n               ; Start listening to history events.\n               (reset! unlisten\n                       (listen history #(dispatch-signal [::on-history-event ; ...\n                                                          ])))\n\n               ; ...               \n               )\n\n      ; Intercept clean up signal.\n      :on-stop\n      (do\n        ; Unsubscribe from history events. \n        ; Otherwise, on hot reload unused listeners will stay in memory.\n        (@unlisten)\n\n        ; There's no need to remove model watchers on hot reload \n        ; because they will be garbage-collected with the model.\n\n        ; Let the wrapped app continue cleaning up.\n        (app-control model signal dispatch-signal dispatch-action))\n\n      ; Middleware-specific signal that will not be passed further to an app.\n      [::on-history-event {:token token :browser-event? browser-event? :event-data event-data}]\n      (do\n        ; Dispatch a middleware-specific action.\n        (dispatch-action [::set-token token])\n\n        (when (or browser-event? (:treat-as-browser-event? event-data))\n          ; Dispatch a signal to an app.\n          (dispatch-signal [::on-enter token])))\n\n      ; Pass other signals further.\n      :else\n      (app-control model signal dispatch-signal dispatch-action)))))\n\n(defn -wrap-reconcile\n  [app-reconcile]\n  (fn reconcile\n    [model action]\n    (match action\n           ; A middleware-specific action.\n           [::set-token token]\n           (assoc model ::token token)\n\n           ; Pass other actions further.\n           :else\n           (app-reconcile model action))))\n\n; History is an injected dependency.\n(defn add\n  [spec history]\n  (-\n spec\n      (update :initial-model -wrap-initial-model)\n      (update :control -wrap-control history)\n      (update :reconcile -wrap-reconcile)))\n\n\n\n\nDebugger\n\n\nOne of the main features of Carry pattern is that it allows time traveling debugging\nsimilar to \nElm's Debugger\n,\n\nRedux DevTools\n and \nCerebral Debugger\n.\n\n\nCarry has its own visual time traveling debugger with next features:\n\n\n\n\nDebugger records all app signals and actions and shows them as a tree.\n\n\nA signal is displayed as a respective tree leaf if it's dispatched from inside another signal.\n\n\nDebugger records results of every action so that every past model value can be logged to console.\n\n\nAny action can be disabled/enabled. On toggling an action debugger will reset app model \nto its initial value and \nreplay\n all enabled actions.\nThis way user can immediately see how the app would look like if the action never took place.\nAction replaying is possible because actions are always pure and change app model in a predictable way.\nOn the other hand, it's impossible to predictably replay signals as they can perform async side effects.\n\n\nClicking a signal toggles all its child actions.\n\n\nClicking \"Replay\" button enables debugger's \"replay mode\" and marks already recorded actions as \"to be replayed\".\nThese actions are saved into local storage and will be automatically replayed on next app start.\nIn combination with Figwheel hot reloading this allows editing reconciler code\nand immediately see how it affects a final app state (effectively \"changing the past\").\n\n\nDebugging session can be saved into a file and then loaded.\n\n\n\"Clear\" button removes all recorded signals and actions without modifying current app state.\n\n\n\"Vacuum\" removes all disabled actions and \"dangling\" signals without enabled actions.\n\n\n\"Reset\" resets an app to its initial state and clears recorded signals and actions.\n\n\nCurrently debugger uses Reagent+jQuery UI to render a resizable overlay view.\n\n\n\n\n\n  \n\n\n\n\nTo use a debugger developer has to apply \ncarry-debugger\n middleware,\nconnect a debugger view and render it alongside an app view:\n\n\n(ns app.core\n  (:require [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [carry-debugger.core :as debugger]\n            [reagent.core :as r]\n            [hodgepodge.core :as hp]\n            ; ...\n            ))\n\n; ...\n\n(defn main\n  []\n  (let [; Use hodgepodge lib for dealing with browser's local storage.\n        storage hp/local-storage\n\n        ; Apply middleware.\n        app-spec (-\n my-spec\n                     ; Middleware requires a storage and a unique storage key.\n                     (debugger/add storage :my-debugger-model))\n\n        ; App and UI.\n        app (carry/app app-spec)\n        [_ app-view] (carry-reagent/connect app my-view-model my-view)\n\n        ; Connect debugger UI.\n        [_ debugger-view] (debugger/connect app)]\n    ; Render app and debugger views.\n    (r/render [:div app-view debugger-view] (.getElementById js/document \nroot\n))\n\n    ; Start.\n    ((:dispatch-signal app) :on-start)\n\n    ; ...\n    ))\n\n\n\n\nThere are cases when you'd like to check if debugger is in replay mode.\nFor instance, \ncarry-history\n\nmiddleware doesn't send its initial \n:on-enter\n signal in replay mode.\nSuch behavior makes live coding more pleasant as developer expects only marked actions to be replayed on app start.\nDebugger mode can be determined by looking at \n[:carry-debugger.core/debugger :replay-mode?]\n path in a model map:\n\n\n(ns carry-history.core\n  ; ...\n  )\n\n; ...\n\n(defn -wrap-control\n  [app-control history]\n  (let [unlisten (atom nil)]\n    (fn control\n      [model signal dispatch-signal dispatch-action]\n      (match signal\n             :on-start\n             (do\n               (app-control model signal dispatch-signal dispatch-action)\n\n               ; ...\n\n               ; Check if we're in replay mode before sending an initial signal\n               (when (not (-\n @model :carry-debugger.core/debugger :replay-mode?))\n                 (dispatch-signal [; ... \n                                   ])))\n             ; ...\n             ))))\n; ...\n\n\n\n\nUnit Testing\n\n\nIt is comparatively easy to unit test a Carry app\nwith Reagent bindings because its behavior is implemented in four functions with explicit dependencies:\n\ncontrol\n, \nreconcile\n, \nview-model\n, \nview\n.\n\n\nLet's look at how these functions are tested in\n\nfriend-list\n example:\n\n\n1. (control model signal dispatch-signal dispatch-action)\n \n\n\nControl function handles incoming signals to perform side effects, dispatch new signals and actions.\nSuch behavior is easy to test using \nmock\n functions.\nThis test uses \nclj-fakes\n \nisolation framework for recording and checking \ndispatch-signal\n and \ndispatch-action\n calls\non receiving \n:on-enter\n signal:\n\n\n(ns unit.controller\n  (:require\n    [friend-list.core :as friend-list]\n    [carry.core :as carry]\n    [carry-history.core :as h]\n    [cljs.test :refer-macros [deftest is testing]]\n    [clj-fakes.core :as f :include-macros true]\n    ;...\n    ))\n\n(deftest\n  on-navigation-updates-query-and-searches\n  (f/with-fakes\n    (let [search (f/fake [[:_new-token f/any?] #(%2 :_found-friends)])\n          {:keys [control]} (friend-list/new-spec :_history search)\n          dispatch-signal (f/recorded-fake)\n          dispatch-action (f/recorded-fake)]\n      ; act\n      (control :_model [::h/on-enter :_new-token] dispatch-signal dispatch-action)\n\n      ; assert\n      (is (f/was-called-once dispatch-action [[:set-query :_new-token]]))\n      (is (f/was-called-once dispatch-signal [[:on-search-success :_new-token :_found-friends]])))))\n\n\n\n\n\n\n\n\nTest is written using \nArrange-Act-Assert (AAA)\n pattern.\nComments are added to better separate these logical blocks.\n\n\n\n\n\n\nControl function is taken from the spec created by \nfriend-list/new-spec\n.\nIt could be tempting to instead test by using \nfriend-list/-new-control\n helper function.\nBut accessing private members is a bad practice\nand there can also be middleware applied inside \nnew-spec\n which can affect the tested behavior:\n\n\n\n\n\n\n{:keys [control]} (friend-list/new-spec :_history search)\n\n\n\n\n\n\nInstead of using a real async API client we create a fake \nsearch\n \nfunction which synchronously returns the expected result and \nwill throw an exception on calls with unexpected arguments:\n\n\n\n\nsearch (f/fake [[:_new-token f/any?] #(%2 :_found-friends)])\n\n\n\n\n\n\nDynamic nature of ClojureScript allows us to use keywords (\n:_history\n, \n:_found-friends\n, \n:_model\n, \n:_new_token\n) instead\nof creating objects of correct type\nwhen we know that their type doesn't really matter in the test case.\nIt makes tests more focused and readable.\n\n\n\n\n2. (reconcile model action)\n\n\nReconciler is the easiest function to test because it's pure:\n\n\n(deftest\n  sets-query\n  (let [{:keys [initial-model reconcile]} (friend-list/new-spec :_history :_search)]\n    (is (= \nnew query\n\n           (:query (reconcile initial-model [:set-query \nnew query\n]))))))\n\n\n\n\nHere again we first create a spec in order to get \ninitial-model\n value and \nreconcile\n function.\n\n\nNotice, that it's impossible to use a \n:_new_query\n keyword because app uses \n\ncarry-schema\n\nmiddleware forcing us to use a string value \n\"new-query\"\n on reconciling.\n\n\n3. (view-model model)\n\n\nThese tests make sure that view model really contains Reagent reactions\nat \n:query\n and \n:friends\n keys:\n\n\n(ns unit.view-model\n  (:require\n    [friend-list.core :as friend-list]\n    [reagent.core :as r]\n    [schema-generators.generators :as g]\n    [cljs.test :refer-macros [deftest is]])\n  (:require-macros [reagent.ratom :refer [run!]]))\n\n(defn test-view-model-tracks-model-key\n  [model-key act-action expected-view-model-value]\n  (let [{:keys [initial-model reconcile]} (friend-list/new-spec :_history :_search)\n        model (r/atom initial-model)\n        view-model (friend-list/view-model model)\n        witness (atom nil)]\n    (is (contains? view-model model-key) \nself-test\n)\n    (run! (reset! witness @(model-key view-model)))\n\n    ; act\n    (swap! model reconcile act-action)\n\n    ; force reaction updates\n    (r/flush)\n\n    ; assert\n    (is (= expected-view-model-value @witness))))\n\n(deftest\n  tracks-query\n  (test-view-model-tracks-model-key :query [:set-query \nnew query\n] \nnew query\n))\n\n(deftest\n  tracks-friends\n  (let [new-friends (g/sample 3 friend-list/Friend)]\n    (test-view-model-tracks-model-key :friends [:set-friends new-friends] new-friends)))\n\n\n\n\n\n\ntest-view-model-tracks-model-key\n is a helper function.\n\n\nr/flush\n is needed because Reagent doesn't immediately propagate reaction updates (starting from v0.6.0).\n\n\nschema-generators\n library is used to automatically generate\n\nnew-friends\n fixture instead of coding it by hand.\n\n\n\n\n4. (view view-model dispatch)\n (This section is a WIP.)\n\n\nUnit testing this function is probably not critical because most error-prone UI\ncode is located in \nview-model\n.\n\n\nComposite Apps\n\n\nBecause Carry architecture is also based on functions which can be nested inside each other,\na pattern similar to \nElm architecture\n \ncan be applied to build composite apps. A composite app incorporates instances of other Carry apps, but\nstill has a single model, controller and reconciler.\n\n\nThough the idea is quite straightforward, it is a debatable design pattern because of the resulting code complexity,\nso use it with caution.\n\n\nLet's look at \ncounter-list\n example.\n\n\n\n\n For a simpler example of a \"statically assembled\" app please check \nsubapps\n project.\n\n\n\n\nIn this project \ncounter apps\n can be created and removed dynamically:\n\n\n\n  \n\n\n\n\n1. initial-model\n\n\nThe model will store a list of counter app models:\n\n\n(def initial-model\n  {; list of [id counter-model] vectors\n   :counters (list)\n   :next-id  0})\n\n\n\n\nSeveral helpers are defined to modify a model:\n\n\n(defn update-counters*\n  \nApplies a function of args [counter-model \n args] to the counters specified by predicate.\n  The function can have side-effects. Returns a new model.\n\n  [model pred f \n args]\n  (letfn [(update-counter [[counter-id counter-model :as counter]]\n            (if (pred counter)\n              [counter-id (apply f counter-model args)]\n              counter))]\n    (update model :counters #(doall (map update-counter %)))))\n\n(defn update-counter\n  [model id f \n args]\n  (apply update-counters* model #(= id (first %)) f args))\n\n(defn update-every-counter\n  [model f \n args]\n  (apply update-counters* model (constantly true) f args))\n\n(defn get-counter\n  [model id]\n  (-\n (:counters model)\n       (filter #(= (first %) id))\n       first\n       second))\n\n\n\n\n2. view-model\n\n\nThe view model will contain \n:counters\n reaction with a list of \n[id counter-view-model]\n pairs:\n\n\n;(defn view-model\n;  \nNaive nonoptimal implementation:\n;   counter view-models will be updated on every model update -\n\n;    every counter view will be reevaluated on each change.\n\n;  [model]\n;  (let [counter-view-model (fn [counter-id]\n;                             (counter/view-model\n;                               (carry/entangle model #(get-counter % counter-id) r/atom)))]\n;    {:counters (reaction (map (fn [[id _counter-model]] [id (counter-view-model id)])\n;                              (:counters @model)))}))\n\n(defn view-model\n  \nOptimized implementation. \n  Reuses counter view-models from the last reaction calculation.\n\n  [model]\n  (let [cached-counter-view-models (atom [])\n        cached-counter-view-model (fn [id]\n                                    (-\n @cached-counter-view-models\n                                         (filter #(= (first %) id))\n                                         first\n                                         second))\n        counter-view-model (fn [id]\n                             (or (cached-counter-view-model id)\n                                 (counter/view-model\n                                   (carry/entangle model #(get-counter % id) r/atom))))]\n    {:counters (reaction (reset! cached-counter-view-models\n                                 (mapv (fn [[id _]] [id (counter-view-model id)])\n                                       (:counters @model))))}))\n\n\n\n\nThe optimized implementation calculates each counter view model only once.\nSo that all existing counter views are not unnecessarily evaluated by Reagent\non updating a single counter.\n\n\nCarry's \nentangle\n helper is used to create a counter model ratom for \ncounter/view-model\n.\nThis call returns a read-only ratom which will automatically sync its value with\n\n(get-counter @model id)\n on \nmodel\n changes:\n\n\n(carry/entangle model #(get-counter % id) r/atom)\n\n\n\n\n3. view\n\n\n(defn tagged\n  \nHelper function decorator which prepends a tag to the single argument.\n  I.e. it transforms an arg x to [tag x].\n\n  [f tag]\n  (fn tagged-fn\n    [x]\n    (f [tag x])))\n\n(defn view-counter\n  [[id view-model] dispatch]\n  [counter/view view-model (tagged dispatch [:on-counter-signal id])])\n\n(defn view\n  [view-model dispatch]\n  (let [counters (map #(view-counter % dispatch) @(:counters view-model))\n        insert [:button {:on-click #(dispatch :on-insert)} \nInsert\n]\n        remove [:button {:on-click #(dispatch :on-remove)} \nRemove\n]]\n    (into [:div insert remove] counters)))\n\n\n\n\nAs you can see, \ncounter/view\n is created for each counter and will dispatch its signals \"tagged\"\nwith a corresponding counter id.\n\n\n4. control\n\n\nThe controller will pass tagged signals to the injected counter controller.\nIn a more complex app we would also have to dispatch tagged \n:on-start\n/\n:on-stop\n signals\non inserting/removing subapps. But in this example we omit this because counter app has no start/stop code:\n\n\n(defn new-control\n  [counter-control]\n  (fn control\n    [model signal dispatch-signal dispatch-action]\n    (match signal\n           :on-insert (dispatch-action :insert)\n           :on-remove (dispatch-action :remove)\n\n           [[:on-counter-signal id] s]\n           (counter-control (carry/entangle model #(get-counter % id))\n                            s\n                            ; Dispatched actions and signals must also be tagged:\n                            (tagged dispatch-signal [:on-counter-signal id])\n                            (tagged dispatch-action [:counter-action id])))))\n\n\n\n\nentangle\n helper is used to create a counter model atom for \ncounter-control\n:\n\n\n(carry/entangle model #(get-counter % id))\n\n\n\n\n5. reconcile\n\n\nReconciler depends on counter's initial model and reconciler:\n\n\n(defn new-reconcile\n  [counter-initial-model counter-reconcile]\n  (fn reconcile\n    [model action]\n    (match action\n           :insert\n           (-\n model\n               (update :counters concat [[(:next-id model) counter-initial-model]])\n               (update :next-id inc))\n\n           :remove\n           (update model :counters rest)\n\n           [[:counter-action id] a]\n           (update-counter model id counter-reconcile a))))\n\n\n\n\n6. main\n\n\nAnd finally, app instantiation code:\n\n\n(ns app.core\n  (:require [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [counter.core :as counter]\n            [reagent.core :as r]\n            [cljs.core.match :refer-macros [match]])\n  (:require-macros [reagent.ratom :refer [reaction]]))\n\n; ...\n\n(defn main\n  []\n  (let [app-spec {:initial-model initial-model\n                  :control       (new-control (:control counter/spec))\n                  :reconcile     (new-reconcile (:initial-model counter/spec) \n                                                (:reconcile counter/spec))}\n        app (carry/app app-spec)\n        [app-view-model app-view] (carry-reagent/connect app view-model view)]\n    (r/render app-view (.getElementById js/document \nroot\n))\n    (assoc app :view-model app-view-model)))\n\n(def app (main))\n\n\n\n\nRouting\n\n\nIt's not uncommon for applications to depend on a current URL and modify it in response to user actions.\nFor these tasks \ncarry-history\n middleware\nprovides a bidirectional synchronization between a browser URL and a model:\n\n\n\n\nAn app can react to URL changes by observing model's \n:token\n (token, roughly, is everything that goes after a hostname).\n\n\nIf token in model is changed by an app then a browser will accordingly update its address bar.\nThis is especially useful during time traveling debugging as toggling token-changing actions will correctly update a URL.\n\n\n\n\n\n\n Examples:\n\n\n\n\nFriend List\n - in this application a token is synced with a search query.\n\n\nTodoMVC\n - here \nSilk\n routing library is added to parse and build tokens.\n\n\n\n\n\n\nUse \nadd\n to apply the middleware\nand don't forget to start the app:\n\n\n(ns app.core\n  (:require [carry.core :as carry] \n            [carry-history.core :as h]\n            ; ...\n            ))\n\n; ...\n\n(let [history (h/new-hash-history)\n      app-spec (-\n my-spec\n                   (h/add history))\n      app (carry/app app-spec)\n      ; ...\n      ]\n    ((:dispatch-signal app) :on-start)\n    ; ...\n\n\n\n\nThe middleware requires a \nHistory API\n \nwrapper to be provided.\nSuch object must satisfy \nHistoryProtocol\n\nand there are several constructors for creating such instances:\n\n\n\n\n\n\n(new-legacy-hash-history)\n\n\n\n\n\n\n(new-hash-history)\n\n\n\n\n\n\n(new-history)\n\n\n\n\n\n\n\n\n carry-history uses \nGoogle Closure\n\nlibrary for interfacing with History API.\n\n\n\n\nA wrapped app can now react to token changes:\n\n\n(defn view-model\n  [model]\n  {:token (reaction (::h/token @model))})\n\n(defn view\n  [{:keys [token] :as _view-model} dispatch]\n  [:p \nCurrent token = \n (pr-str @token)])\n\n\n\n\nIt also becomes possible to react to token changes by handling \n::on-enter\n signal.\nIt will be dispatched on app start and on changes initiated by user actions (e.g. editing an address or clicking Back button):\n\n\n(match signal\n       [::h/on-enter token]\n       (println \nnavigated to page at \n (pr-str token))\n\n       ; ...\n\n\n\n\nPackage's \nlink\n Reagent component can be used to create in-app links which don't hit the server.\nAn example from \nTodoMVC\n:\n\n\n(defn -footer-filters\n  [visibility-spec history]\n  [:ul.filters\n   (for [{:keys [title route selected?]} visibility-spec]\n     ^{:key route}\n     [:li [h/link history (router/route-\ntoken route)\n           {:class (if selected? \nselected\n)}\n           title]])])\n\n\n\n\nPlease see \nAPI reference\n for more info.\n\n\nUsage with DataScript\n\n\nSee examples:\n\n\n\n\nCounter DataScript\n\n\nShopping Cart", 
            "title": "User Guide"
        }, 
        {
            "location": "/user-guide/#basics", 
            "text": "This section explains everything you need to start making apps with Carry.", 
            "title": "Basics"
        }, 
        {
            "location": "/user-guide/#app", 
            "text": "In a Carry application all the code you write is encapsulated behind a single  app  instance. \nAn app is a map with keys:   :model  - a read-only atom, an in-memory representation of an app state  :dispatch-signal  - a function for interaction with an app, always returns nil   One can consider an app to be a black box which exposes its current state and modifies it on getting signals from an external world.\nIt can also affect an external world as a response to a signal, i.e. perform \"side effects\".", 
            "title": "App"
        }, 
        {
            "location": "/user-guide/#model", 
            "text": "Model represents an entire state of an app.   One can access app's model via  :model  key to obtain a read-only atom that can be dereferenced and watched, but cannot be mutated:  (def my-model (:model app))\n\n@my-model\n;=  {...}\n\n(add-watch my-model :my-watcher\n           (fn [_key _atom old-state new-state]\n             (when (not= old-state new-state)\n               (println  model value has changed! ))))\n\n(reset! my-model {:foo :bar})\n;=  Error: read-only atom cannot be reset to {:foo :bar}\n\n((:dispatch-signal app) some-model-changing-signal)\n;=  model value has changed!\n\n(remove-watch my-model :my-watcher)  Carry requires a model value to be a map. This convention allows writing reusable packages that can store additional data into any Carry app.\nAs an example,  carry-history  adds  :token  to a model.", 
            "title": "Model"
        }, 
        {
            "location": "/user-guide/#signals", 
            "text": "Signal  is an object which represents a user's intention or, looking at it from a different angle, a system event. \nSignal can be synchronously sent to an app by calling its  dispatch-signal  function:  ((:dispatch-signal my-app) my-signal)  Carry accepts signals of any type. But usually signal is a just keyword with the \"on-\" prefix or\na serializable vector with a keyword and an additional payload:  :on-clear-completed\n[:on-update-todo id val]\n[:carry-history.core/on-enter token]", 
            "title": "Signals"
        }, 
        {
            "location": "/user-guide/#creating-an-app", 
            "text": "In order to create an instance of a Carry app a user has to pass a  spec  into  app  function:  (let [my-app (carry/app my-spec)]\n  ; ...\n  )  A spec is a map with keys:   :initial-model  - an initial model value  :control  - a function for handling signals  :reconcile  - a function for handling actions   In other words, a spec is needed to define a runtime behavior of an app:", 
            "title": "Creating an App"
        }, 
        {
            "location": "/user-guide/#control", 
            "text": "Controller (control function, control)  is a part of an application responsible for handling incoming signals. \nIt can dispatch new signals, modify app model (by dispatching actions) and perform any side effects (e.g. send data to a server).\nController is also free to contain an asynchronous code. The signature of a control function:  (defn control\n  [model signal dispatch-signal dispatch-action])   model  - a read-only atom, the same as app's  :model  signal  - an incoming signal   dispatch-signal  - a synchronous function for dispatching new signals, always returns  nil , the same as app's  :dispatch-signal  dispatch-action  - a synchronous function for modifying a model, always returns  nil  Return value will not be used   By convention, control should be able to at least handle  :on-start  and  :on-stop  signals.\nAs we'll see later, it's required by middleware with setup/teardown logic and to support hot reloading.  It is convenient (but not required) to use  pattern matching  \nto switch between signals and destructure signals with payload.\nAs an example, this is a controller from  friend-list  demo app:  (ns friend-list.core\n  (:require [carry-history.core :as h]\n            ; ...\n            [goog.functions :refer [debounce]]\n            [cljs.core.match :refer-macros [match]]))\n\n; It's recommended to create a factory function if controller uses external dependencies.\n; It makes code more decoupled and \n; easier to unit test (stubs/mocks can be easily used instead of real implementations).\n; In this example browser history manager and API client are external dependencies.\n(defn -new-control\n  [history api-search]\n  ; Some helper functions.\n  ; On successful search a new :on-search-success signal will be dispatched.\n  (let [search (fn [q dispatch-signal] (api-search q #(dispatch-signal [:on-search-success q %])))\n        search-on-input (debounce (fn [q dispatch-signal]\n                                    (h/push-token history q)\n                                    (search q dispatch-signal))\n                                  300)]\n    ; Function name is specified for better stacktraces.\n    (fn control\n      [model signal dispatch-signal dispatch-action]\n      (match signal\n             ; This application has no custom setup/teardown logic\n             ; so just return nil on standard signals:             \n             :on-start nil\n             :on-stop nil\n\n             ; Macro will throw an exception on unknown signals.\n\n             ; Signal destructuring example \n             [:on-input q]\n             (do\n               ; Update model.\n               (dispatch-action [:set-query q])\n\n               ; Begin (possibly async) searching.\n               (search-on-input q dispatch-signal))\n\n             ; ...\n\n             [:on-search-success q friends]\n             ; Note that model has to be dereferenced to get its value.\n             (if (= (:query @model) q)\n               (dispatch-action [:set-friends friends])\n               (println  ignore response for  (pr-str q)\n                         because current query is  (pr-str (:query @model))))))))\n\n; ...\n\n; Dependencies will be injected in a spec factory function:\n(defn new-spec\n  [history api-search]\n  {; ...\n   :control (-new-control history api-search)})\n\n; ...\n\n; Create and start an app using concrete dependencies.\n(def my-app (carry/app (new-spec my-history my-api-client)))\n((:dispatch-signal app) :on-start)", 
            "title": "Control"
        }, 
        {
            "location": "/user-guide/#actions", 
            "text": "Action  is an object which represents an intention to modify a model.\nActions can be dispatched only from within a control function via  dispatch-action .  Similar to signals, actions are usually keywords or vectors, for instance:  :increment\n[:set-query q]", 
            "title": "Actions"
        }, 
        {
            "location": "/user-guide/#reconcile", 
            "text": "Reconciler (reconcile function, reconcile)  is a part of an application responsible for handling incoming actions.\nIt's a pure function which returns a new model value based on a current model value and an incoming action.\nOn getting an action an app passes it into a reconciler and then resets app model value with the result.  A simple example from  friend-list  demo app:  (defn -reconcile\n  [model action]\n  (match action\n         [:set-query q]\n         (assoc model :query q)\n\n         [:set-friends friends]\n         (assoc model :friends friends)))  It's important to not put any async code, side effects or nondeterministic code (e.g. random number generation)\ninto reconciler. Otherwise, it will make replaying actions unpredictable and break time traveling debugging.", 
            "title": "Reconcile"
        }, 
        {
            "location": "/user-guide/#usage-with-reagent", 
            "text": "Carry can work with any view layer that is able to re-render UI in response to app model changes.\nThis chapter is about tying Carry with  Reagent  \n(a ClojureScript wrapper for  React )\nusing  carry-reagent  package:   (ns app.core\n  (:require [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [reagent.core :as r]))\n\n; ...\n\n; Define app view model and view:\n\n(defn my-view-model\n  [model]\n  ; define a view model...\n)\n\n(defn my-view\n  [view-model dispatch]\n  ; a Reagent component that uses data from a view-model and dispatches signals on events...\n)\n\n(let [; Create an app.\n      app (carry/app my-spec)\n\n      ;  Connect  app, view model and view to create a Reagent component.\n      [_ app-view] (carry-reagent/connect app my-view-model my-view)]\n    ; Render component into DOM.\n    (r/render app-view (.getElementById js/document  root ))\n\n    ; ...\n)  App view is constructed using  carry-reagent.core/connect  function:  (connect [app view-model view])   app  - Carry app instance  view-model  - a function which produces a view model  view  - a Reagent component  Returns a pair  [view-model-instance view-component]  (view model is returned mainly for debugging)   view-model  function is called once on  connect  call.\nThen returned view model instance is passed as an argument into  view  function to produce a final view component.\nA view thereby listens to a view model that in turn listens to a model:   In the next section we'll see how to define a view model.", 
            "title": "Usage with Reagent"
        }, 
        {
            "location": "/user-guide/#view-model", 
            "text": "View model  contains all the data needed to render a UI.\nIt can compute derived model data, split lists of objects into pages, calculate which buttons are enabled, \ndetermine which app page to show depending on current URL, etc.  Usually view model is a map of Reagent reactions. An example from  TodoMVC  app:  (ns app.view-model\n  (:require ; ...\n            [carry-reagent.core :as carry-reagent])\n  (:require-macros [reagent.ratom :refer [reaction]]))\n\n(defn view-model\n  [model]\n  (let [; ...\n        ; Wrap todo items in a reaction.\n        all-todos (reaction (:todos @model))]\n    (-  model\n        ; This helper function call will return {:field (reaction (:field @model))} map.\n        ; Note: :field contains the value of a new todo input.\n        (carry-reagent/track-keys [:field])\n\n        ; Additional view model fields are reactions \n        ; which will be recalculated if (and only if) all-todos value changes:\n        (assoc :has-todos? (reaction (-  @all-todos count pos?))\n               :all-completed? (reaction (every? :completed? @all-todos))\n               ; ...\n               ))))  Argument  model  is a read-only  Reagent atom (ratom)  that behaves almost exactly as a read-only model atom (i.e.  (:model app) ), \nbut can also be used in Reagent components and reactions.  Reaction  is a special ratom-like object that is created using Reagent's  reaction  macro.\nIt is lazily computed from other ratoms/reactions.\nAny Reagent component that dereferences a reaction is going to be re-rendered when reaction value updates.", 
            "title": "View Model"
        }, 
        {
            "location": "/user-guide/#view", 
            "text": "An example from  TodoMVC  app:  ; A plain Reagent component which is redrawn when input arguments change.\n(defn -header\n  [field dispatch]\n  ; Reagent uses Hiccup-like syntax for defining HTML.\n  [:header.header\n   [:h1  todos ]\n\n   ; Input value is equal to field arg value.\n   [:input.new-todo {:placeholder  What needs to be done? \n                     :value       field\n\n                     ; Dispatch signals on input events.\n                     :on-change   #(dispatch [:on-update-field (.. % -target -value)])\n                     :on-key-down #(when (-enter-key? %) (dispatch :on-add))}]])\n\n; Top app component that is passed into connect function.\n(defn view\n  ; Destructure view model map for cleaner code in the function body.\n  [{:keys [field has-todos? all-completed?\n           ; ...\n           ] :as _view-model}\n   dispatch]\n  [:section.todoapp\n   ; Deref |field| reaction to get its value for rendering.\n   ; Derefing also makes parent component start watching for |field| changes \n   ; so that -header will be re-rendered on |field| updates. \n   [-header @field dispatch]\n\n   ; ...\n   ]))  As you can see, we get reactions from a view model and deref them to render actual values.\nReagent will then \"magically\" re-render components when the reactions passed into them are updated.", 
            "title": "View"
        }, 
        {
            "location": "/user-guide/#usage-with-figwheel", 
            "text": "With  Figwheel  Leiningen plugin it is possible to:   compile and reload app code in browser on source code changes  communicate with a running app via REPL   All the Carry  examples  use Figwheel for development builds and \nrely on the \"bare\"  lein-cljsbuild  for production builds.  The main thing to remember is to stop the currently running app before hot reload \nin order to unsubscribe it from browser events and free memory.\nHere's how you can structure your main app file to be used with Figwheel:   (ns app.core\n  (:require [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [reagent.core :as r]))\n\n; ...\n\n(defn main\n  []\n  (let [app (carry/app my-spec)\n        [app-view-model app-view] (carry-reagent/connect app my-view-model my-view)]\n    (r/render app-view (.getElementById js/document  root ))\n\n    ; Start the app.\n    ((:dispatch-signal app) :on-start)\n\n    ; For debugging purposes add view-model into returned map.\n    (assoc app :view-model app-view-model)))\n\n; Start new app and save it into the global var for debugging in REPL.\n(def app (main))\n\n;;;;;;;;;;;;;;;;;;;;;;;; Figwheel stuff\n; These functions should be specified in project.clj :figwheel map.\n\n; Stop current app before loading a new one.\n(defn before-jsload\n  []\n  ((:dispatch-signal app) :on-stop))\n\n(defn on-jsload\n  []\n  #_(. js/console clear))", 
            "title": "Usage with Figwheel"
        }, 
        {
            "location": "/user-guide/#advanced", 
            "text": "", 
            "title": "Advanced"
        }, 
        {
            "location": "/user-guide/#middleware", 
            "text": "Middleware  is a function that gets an app spec and returns an updated spec\nin order to introduce some new app behavior (such as logging, syncing with server, crash reporting).    Also see:  ready-to-use middleware packages .   Multiple middleware can be applied in a chain to produce a new spec.\nFor instance,  TodoMVC  app spec is wrapped by three middleware:  (defn new-spec\n  [history storage storage-key todo-titles]\n  (-  {:initial-model (model/new-model todo-titles)\n       :control       control\n       :reconcile     reconcile}\n\n      ; 1\n      (schema/add model/Schema)\n\n      ; 2\n      (persistence/add storage storage-key {:blacklist #{::h/token}})\n\n      ; 3\n      (h/add history)))  As an example, this is a simple middleware which logs all actions and signals coming through an app:  (ns carry-logging.core)\n\n(defn add\n   Will print all signals and actions to console. \n  ([spec] (add spec  ))\n  ([spec prefix]\n   (-  spec\n       ; Wrap control to log signals.\n       (update :control (fn wrap-control [control]\n                          (fn logged-control [model signal dispatch-signal dispatch-action]\n                            (try\n                              ; Log.\n                              (.group js/console (str prefix  signal   (pr-str signal)))\n\n                              ; Call original function.\n                              (control model signal dispatch-signal dispatch-action)\n\n                              ; Always close the group.\n                              (finally\n                                (.groupEnd js/console))))))\n\n       ; Wrap reconcile to log actions.\n       (update :reconcile\n               (fn wrap-reconcile [reconcile]\n                 (fn logged-reconcile [model action]\n                   ; Log.\n                   (.log js/console (str prefix  action ) (pr-str action))\n\n                   ; Call original function.\n                   (reconcile model action)))))))  More complex middleware can:   Modify initial model.  Intercept  :on-start / :on-stop  signals.  Dispatch new signals and actions to an app.\nBy convention, they must use namespaced keywords (e.g.  :my-middlware.core/on-something ) to prevent a name clash with other signals.  Dispatch own signals and actions which should not be handled by an app. They must also use namespaced keywords.  Subscribe to model changes.  Have injected dependencies.   All these cases are demonstrated by  carry-history  middleware:  (ns carry-history.core\n  ; ...\n)\n\n(defn -wrap-initial-model\n  [app-initial-model]\n  (merge {::token  / } app-initial-model))\n\n; History will be injected on applying the middleware.\n(defn -wrap-control\n  [app-control history]\n  (let [unlisten (atom nil)]\n    (fn control\n      [model signal dispatch-signal dispatch-action]\n      (match signal\n             ; Intercept :on-start signal.\n             :on-start\n             (do\n               ; Let the wrapped app start first.\n               (app-control model signal dispatch-signal dispatch-action)\n\n               ; Start listening to model updates.\n               (add-watch model ::token-watcher\n                          (fn [_key _atom old-state new-state]\n                            ; ...\n                            ))\n\n               ; Start listening to history events.\n               (reset! unlisten\n                       (listen history #(dispatch-signal [::on-history-event ; ...\n                                                          ])))\n\n               ; ...               \n               )\n\n      ; Intercept clean up signal.\n      :on-stop\n      (do\n        ; Unsubscribe from history events. \n        ; Otherwise, on hot reload unused listeners will stay in memory.\n        (@unlisten)\n\n        ; There's no need to remove model watchers on hot reload \n        ; because they will be garbage-collected with the model.\n\n        ; Let the wrapped app continue cleaning up.\n        (app-control model signal dispatch-signal dispatch-action))\n\n      ; Middleware-specific signal that will not be passed further to an app.\n      [::on-history-event {:token token :browser-event? browser-event? :event-data event-data}]\n      (do\n        ; Dispatch a middleware-specific action.\n        (dispatch-action [::set-token token])\n\n        (when (or browser-event? (:treat-as-browser-event? event-data))\n          ; Dispatch a signal to an app.\n          (dispatch-signal [::on-enter token])))\n\n      ; Pass other signals further.\n      :else\n      (app-control model signal dispatch-signal dispatch-action)))))\n\n(defn -wrap-reconcile\n  [app-reconcile]\n  (fn reconcile\n    [model action]\n    (match action\n           ; A middleware-specific action.\n           [::set-token token]\n           (assoc model ::token token)\n\n           ; Pass other actions further.\n           :else\n           (app-reconcile model action))))\n\n; History is an injected dependency.\n(defn add\n  [spec history]\n  (-  spec\n      (update :initial-model -wrap-initial-model)\n      (update :control -wrap-control history)\n      (update :reconcile -wrap-reconcile)))", 
            "title": "Middleware"
        }, 
        {
            "location": "/user-guide/#debugger", 
            "text": "One of the main features of Carry pattern is that it allows time traveling debugging\nsimilar to  Elm's Debugger , Redux DevTools  and  Cerebral Debugger .  Carry has its own visual time traveling debugger with next features:   Debugger records all app signals and actions and shows them as a tree.  A signal is displayed as a respective tree leaf if it's dispatched from inside another signal.  Debugger records results of every action so that every past model value can be logged to console.  Any action can be disabled/enabled. On toggling an action debugger will reset app model \nto its initial value and  replay  all enabled actions.\nThis way user can immediately see how the app would look like if the action never took place.\nAction replaying is possible because actions are always pure and change app model in a predictable way.\nOn the other hand, it's impossible to predictably replay signals as they can perform async side effects.  Clicking a signal toggles all its child actions.  Clicking \"Replay\" button enables debugger's \"replay mode\" and marks already recorded actions as \"to be replayed\".\nThese actions are saved into local storage and will be automatically replayed on next app start.\nIn combination with Figwheel hot reloading this allows editing reconciler code\nand immediately see how it affects a final app state (effectively \"changing the past\").  Debugging session can be saved into a file and then loaded.  \"Clear\" button removes all recorded signals and actions without modifying current app state.  \"Vacuum\" removes all disabled actions and \"dangling\" signals without enabled actions.  \"Reset\" resets an app to its initial state and clears recorded signals and actions.  Currently debugger uses Reagent+jQuery UI to render a resizable overlay view.   \n     To use a debugger developer has to apply  carry-debugger  middleware,\nconnect a debugger view and render it alongside an app view:  (ns app.core\n  (:require [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [carry-debugger.core :as debugger]\n            [reagent.core :as r]\n            [hodgepodge.core :as hp]\n            ; ...\n            ))\n\n; ...\n\n(defn main\n  []\n  (let [; Use hodgepodge lib for dealing with browser's local storage.\n        storage hp/local-storage\n\n        ; Apply middleware.\n        app-spec (-  my-spec\n                     ; Middleware requires a storage and a unique storage key.\n                     (debugger/add storage :my-debugger-model))\n\n        ; App and UI.\n        app (carry/app app-spec)\n        [_ app-view] (carry-reagent/connect app my-view-model my-view)\n\n        ; Connect debugger UI.\n        [_ debugger-view] (debugger/connect app)]\n    ; Render app and debugger views.\n    (r/render [:div app-view debugger-view] (.getElementById js/document  root ))\n\n    ; Start.\n    ((:dispatch-signal app) :on-start)\n\n    ; ...\n    ))  There are cases when you'd like to check if debugger is in replay mode.\nFor instance,  carry-history \nmiddleware doesn't send its initial  :on-enter  signal in replay mode.\nSuch behavior makes live coding more pleasant as developer expects only marked actions to be replayed on app start.\nDebugger mode can be determined by looking at  [:carry-debugger.core/debugger :replay-mode?]  path in a model map:  (ns carry-history.core\n  ; ...\n  )\n\n; ...\n\n(defn -wrap-control\n  [app-control history]\n  (let [unlisten (atom nil)]\n    (fn control\n      [model signal dispatch-signal dispatch-action]\n      (match signal\n             :on-start\n             (do\n               (app-control model signal dispatch-signal dispatch-action)\n\n               ; ...\n\n               ; Check if we're in replay mode before sending an initial signal\n               (when (not (-  @model :carry-debugger.core/debugger :replay-mode?))\n                 (dispatch-signal [; ... \n                                   ])))\n             ; ...\n             ))))\n; ...", 
            "title": "Debugger"
        }, 
        {
            "location": "/user-guide/#unit-testing", 
            "text": "It is comparatively easy to unit test a Carry app\nwith Reagent bindings because its behavior is implemented in four functions with explicit dependencies: control ,  reconcile ,  view-model ,  view .  Let's look at how these functions are tested in friend-list  example:  1. (control model signal dispatch-signal dispatch-action)    Control function handles incoming signals to perform side effects, dispatch new signals and actions.\nSuch behavior is easy to test using  mock  functions.\nThis test uses  clj-fakes  \nisolation framework for recording and checking  dispatch-signal  and  dispatch-action  calls\non receiving  :on-enter  signal:  (ns unit.controller\n  (:require\n    [friend-list.core :as friend-list]\n    [carry.core :as carry]\n    [carry-history.core :as h]\n    [cljs.test :refer-macros [deftest is testing]]\n    [clj-fakes.core :as f :include-macros true]\n    ;...\n    ))\n\n(deftest\n  on-navigation-updates-query-and-searches\n  (f/with-fakes\n    (let [search (f/fake [[:_new-token f/any?] #(%2 :_found-friends)])\n          {:keys [control]} (friend-list/new-spec :_history search)\n          dispatch-signal (f/recorded-fake)\n          dispatch-action (f/recorded-fake)]\n      ; act\n      (control :_model [::h/on-enter :_new-token] dispatch-signal dispatch-action)\n\n      ; assert\n      (is (f/was-called-once dispatch-action [[:set-query :_new-token]]))\n      (is (f/was-called-once dispatch-signal [[:on-search-success :_new-token :_found-friends]])))))    Test is written using  Arrange-Act-Assert (AAA)  pattern.\nComments are added to better separate these logical blocks.    Control function is taken from the spec created by  friend-list/new-spec .\nIt could be tempting to instead test by using  friend-list/-new-control  helper function.\nBut accessing private members is a bad practice\nand there can also be middleware applied inside  new-spec  which can affect the tested behavior:    {:keys [control]} (friend-list/new-spec :_history search)   Instead of using a real async API client we create a fake  search  \nfunction which synchronously returns the expected result and \nwill throw an exception on calls with unexpected arguments:   search (f/fake [[:_new-token f/any?] #(%2 :_found-friends)])   Dynamic nature of ClojureScript allows us to use keywords ( :_history ,  :_found-friends ,  :_model ,  :_new_token ) instead\nof creating objects of correct type\nwhen we know that their type doesn't really matter in the test case.\nIt makes tests more focused and readable.   2. (reconcile model action)  Reconciler is the easiest function to test because it's pure:  (deftest\n  sets-query\n  (let [{:keys [initial-model reconcile]} (friend-list/new-spec :_history :_search)]\n    (is (=  new query \n           (:query (reconcile initial-model [:set-query  new query ]))))))  Here again we first create a spec in order to get  initial-model  value and  reconcile  function.  Notice, that it's impossible to use a  :_new_query  keyword because app uses  carry-schema \nmiddleware forcing us to use a string value  \"new-query\"  on reconciling.  3. (view-model model)  These tests make sure that view model really contains Reagent reactions\nat  :query  and  :friends  keys:  (ns unit.view-model\n  (:require\n    [friend-list.core :as friend-list]\n    [reagent.core :as r]\n    [schema-generators.generators :as g]\n    [cljs.test :refer-macros [deftest is]])\n  (:require-macros [reagent.ratom :refer [run!]]))\n\n(defn test-view-model-tracks-model-key\n  [model-key act-action expected-view-model-value]\n  (let [{:keys [initial-model reconcile]} (friend-list/new-spec :_history :_search)\n        model (r/atom initial-model)\n        view-model (friend-list/view-model model)\n        witness (atom nil)]\n    (is (contains? view-model model-key)  self-test )\n    (run! (reset! witness @(model-key view-model)))\n\n    ; act\n    (swap! model reconcile act-action)\n\n    ; force reaction updates\n    (r/flush)\n\n    ; assert\n    (is (= expected-view-model-value @witness))))\n\n(deftest\n  tracks-query\n  (test-view-model-tracks-model-key :query [:set-query  new query ]  new query ))\n\n(deftest\n  tracks-friends\n  (let [new-friends (g/sample 3 friend-list/Friend)]\n    (test-view-model-tracks-model-key :friends [:set-friends new-friends] new-friends)))   test-view-model-tracks-model-key  is a helper function.  r/flush  is needed because Reagent doesn't immediately propagate reaction updates (starting from v0.6.0).  schema-generators  library is used to automatically generate new-friends  fixture instead of coding it by hand.   4. (view view-model dispatch)  (This section is a WIP.)  Unit testing this function is probably not critical because most error-prone UI\ncode is located in  view-model .", 
            "title": "Unit Testing"
        }, 
        {
            "location": "/user-guide/#composite-apps", 
            "text": "Because Carry architecture is also based on functions which can be nested inside each other,\na pattern similar to  Elm architecture  \ncan be applied to build composite apps. A composite app incorporates instances of other Carry apps, but\nstill has a single model, controller and reconciler.  Though the idea is quite straightforward, it is a debatable design pattern because of the resulting code complexity,\nso use it with caution.  Let's look at  counter-list  example.    For a simpler example of a \"statically assembled\" app please check  subapps  project.   In this project  counter apps  can be created and removed dynamically:  \n     1. initial-model  The model will store a list of counter app models:  (def initial-model\n  {; list of [id counter-model] vectors\n   :counters (list)\n   :next-id  0})  Several helpers are defined to modify a model:  (defn update-counters*\n   Applies a function of args [counter-model   args] to the counters specified by predicate.\n  The function can have side-effects. Returns a new model. \n  [model pred f   args]\n  (letfn [(update-counter [[counter-id counter-model :as counter]]\n            (if (pred counter)\n              [counter-id (apply f counter-model args)]\n              counter))]\n    (update model :counters #(doall (map update-counter %)))))\n\n(defn update-counter\n  [model id f   args]\n  (apply update-counters* model #(= id (first %)) f args))\n\n(defn update-every-counter\n  [model f   args]\n  (apply update-counters* model (constantly true) f args))\n\n(defn get-counter\n  [model id]\n  (-  (:counters model)\n       (filter #(= (first %) id))\n       first\n       second))  2. view-model  The view model will contain  :counters  reaction with a list of  [id counter-view-model]  pairs:  ;(defn view-model\n;   Naive nonoptimal implementation:\n;   counter view-models will be updated on every model update - \n;    every counter view will be reevaluated on each change. \n;  [model]\n;  (let [counter-view-model (fn [counter-id]\n;                             (counter/view-model\n;                               (carry/entangle model #(get-counter % counter-id) r/atom)))]\n;    {:counters (reaction (map (fn [[id _counter-model]] [id (counter-view-model id)])\n;                              (:counters @model)))}))\n\n(defn view-model\n   Optimized implementation. \n  Reuses counter view-models from the last reaction calculation. \n  [model]\n  (let [cached-counter-view-models (atom [])\n        cached-counter-view-model (fn [id]\n                                    (-  @cached-counter-view-models\n                                         (filter #(= (first %) id))\n                                         first\n                                         second))\n        counter-view-model (fn [id]\n                             (or (cached-counter-view-model id)\n                                 (counter/view-model\n                                   (carry/entangle model #(get-counter % id) r/atom))))]\n    {:counters (reaction (reset! cached-counter-view-models\n                                 (mapv (fn [[id _]] [id (counter-view-model id)])\n                                       (:counters @model))))}))  The optimized implementation calculates each counter view model only once.\nSo that all existing counter views are not unnecessarily evaluated by Reagent\non updating a single counter.  Carry's  entangle  helper is used to create a counter model ratom for  counter/view-model .\nThis call returns a read-only ratom which will automatically sync its value with (get-counter @model id)  on  model  changes:  (carry/entangle model #(get-counter % id) r/atom)  3. view  (defn tagged\n   Helper function decorator which prepends a tag to the single argument.\n  I.e. it transforms an arg x to [tag x]. \n  [f tag]\n  (fn tagged-fn\n    [x]\n    (f [tag x])))\n\n(defn view-counter\n  [[id view-model] dispatch]\n  [counter/view view-model (tagged dispatch [:on-counter-signal id])])\n\n(defn view\n  [view-model dispatch]\n  (let [counters (map #(view-counter % dispatch) @(:counters view-model))\n        insert [:button {:on-click #(dispatch :on-insert)}  Insert ]\n        remove [:button {:on-click #(dispatch :on-remove)}  Remove ]]\n    (into [:div insert remove] counters)))  As you can see,  counter/view  is created for each counter and will dispatch its signals \"tagged\"\nwith a corresponding counter id.  4. control  The controller will pass tagged signals to the injected counter controller.\nIn a more complex app we would also have to dispatch tagged  :on-start / :on-stop  signals\non inserting/removing subapps. But in this example we omit this because counter app has no start/stop code:  (defn new-control\n  [counter-control]\n  (fn control\n    [model signal dispatch-signal dispatch-action]\n    (match signal\n           :on-insert (dispatch-action :insert)\n           :on-remove (dispatch-action :remove)\n\n           [[:on-counter-signal id] s]\n           (counter-control (carry/entangle model #(get-counter % id))\n                            s\n                            ; Dispatched actions and signals must also be tagged:\n                            (tagged dispatch-signal [:on-counter-signal id])\n                            (tagged dispatch-action [:counter-action id])))))  entangle  helper is used to create a counter model atom for  counter-control :  (carry/entangle model #(get-counter % id))  5. reconcile  Reconciler depends on counter's initial model and reconciler:  (defn new-reconcile\n  [counter-initial-model counter-reconcile]\n  (fn reconcile\n    [model action]\n    (match action\n           :insert\n           (-  model\n               (update :counters concat [[(:next-id model) counter-initial-model]])\n               (update :next-id inc))\n\n           :remove\n           (update model :counters rest)\n\n           [[:counter-action id] a]\n           (update-counter model id counter-reconcile a))))  6. main  And finally, app instantiation code:  (ns app.core\n  (:require [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [counter.core :as counter]\n            [reagent.core :as r]\n            [cljs.core.match :refer-macros [match]])\n  (:require-macros [reagent.ratom :refer [reaction]]))\n\n; ...\n\n(defn main\n  []\n  (let [app-spec {:initial-model initial-model\n                  :control       (new-control (:control counter/spec))\n                  :reconcile     (new-reconcile (:initial-model counter/spec) \n                                                (:reconcile counter/spec))}\n        app (carry/app app-spec)\n        [app-view-model app-view] (carry-reagent/connect app view-model view)]\n    (r/render app-view (.getElementById js/document  root ))\n    (assoc app :view-model app-view-model)))\n\n(def app (main))", 
            "title": "Composite Apps"
        }, 
        {
            "location": "/user-guide/#routing", 
            "text": "It's not uncommon for applications to depend on a current URL and modify it in response to user actions.\nFor these tasks  carry-history  middleware\nprovides a bidirectional synchronization between a browser URL and a model:   An app can react to URL changes by observing model's  :token  (token, roughly, is everything that goes after a hostname).  If token in model is changed by an app then a browser will accordingly update its address bar.\nThis is especially useful during time traveling debugging as toggling token-changing actions will correctly update a URL.     Examples:   Friend List  - in this application a token is synced with a search query.  TodoMVC  - here  Silk  routing library is added to parse and build tokens.    Use  add  to apply the middleware\nand don't forget to start the app:  (ns app.core\n  (:require [carry.core :as carry] \n            [carry-history.core :as h]\n            ; ...\n            ))\n\n; ...\n\n(let [history (h/new-hash-history)\n      app-spec (-  my-spec\n                   (h/add history))\n      app (carry/app app-spec)\n      ; ...\n      ]\n    ((:dispatch-signal app) :on-start)\n    ; ...  The middleware requires a  History API  \nwrapper to be provided.\nSuch object must satisfy  HistoryProtocol \nand there are several constructors for creating such instances:    (new-legacy-hash-history)    (new-hash-history)    (new-history)      carry-history uses  Google Closure \nlibrary for interfacing with History API.   A wrapped app can now react to token changes:  (defn view-model\n  [model]\n  {:token (reaction (::h/token @model))})\n\n(defn view\n  [{:keys [token] :as _view-model} dispatch]\n  [:p  Current token =   (pr-str @token)])  It also becomes possible to react to token changes by handling  ::on-enter  signal.\nIt will be dispatched on app start and on changes initiated by user actions (e.g. editing an address or clicking Back button):  (match signal\n       [::h/on-enter token]\n       (println  navigated to page at   (pr-str token))\n\n       ; ...  Package's  link  Reagent component can be used to create in-app links which don't hit the server.\nAn example from  TodoMVC :  (defn -footer-filters\n  [visibility-spec history]\n  [:ul.filters\n   (for [{:keys [title route selected?]} visibility-spec]\n     ^{:key route}\n     [:li [h/link history (router/route- token route)\n           {:class (if selected?  selected )}\n           title]])])  Please see  API reference  for more info.", 
            "title": "Routing"
        }, 
        {
            "location": "/user-guide/#usage-with-datascript", 
            "text": "See examples:   Counter DataScript  Shopping Cart", 
            "title": "Usage with DataScript"
        }, 
        {
            "location": "/examples/", 
            "text": "All source code can be found in \nthe Github repository\n.\n\n\nAll apps support hot reloading and REPL debugging via \nFigwheel\n.\n\n\nCounter Vanilla\n\n\nSource code\n\n\nDemo\n\n\nThe most trivial example. Uses \"vanilla\" JavaScript to render a UI.\n\n\nCounter\n\n\nSource code\n\n\nDemo\n\n\nThe basic example of using Carry with Reagent.\n\n\nFriend List\n\n\nSource code\n\n\nDemo\n\n\nInspired by this \nproblem\n about dynamic search input.\nDemonstrates how to dispatch new signals from app controller and also features:\n\n\n\n\nbasic routing\n\n\nmodel validation using \nSchema\n\n\ntime traveling debugger\n\n\nlogging to console\n\n\nunit tests\n\n\n\n\nTodoMVC\n\n\nSource code\n\n\nDemo\n\n\nSee \ntodomvc.com\n.\n\n\nFeatures:\n\n\n\n\nrouting using \nSilk\n\n\nlocal storage persistence\n\n\ntime traveling debugger\n\n\nlogging to console\n\n\nmodel validation using \nSchema\n\n\nuses \nSpecter\n for model updates\n\n\n\n\nCounter DataScript\n\n\nSource code\n\n\nDemo\n\n\nSimplest example of using \nDataScript\n in-memory database for a model.\n\n\nShopping Cart\n\n\nSource code\n\n\nDemo\n\n\nMore advanced example of using \nDataScript\n.\nInspired by \nflux-comparison\n problem.\n\n\nComposite Apps\n\n\nSubapps\n\n\nSource code\n\n\nDemo\n\n\nIn this project \ncounter app\n and \nfriend list app\n instances are \"statically\" added to the app spec.\nSeveral helper methods are extracted to make it easy to include any subapp at the time of app instantiation.\n\n\nCounter List\n\n\nSource code\n\n\nDemo\n\n\nIn this example \ncounter app\n instances are created and removed dynamically after app is started.", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#counter-vanilla", 
            "text": "Source code  Demo  The most trivial example. Uses \"vanilla\" JavaScript to render a UI.", 
            "title": "Counter Vanilla"
        }, 
        {
            "location": "/examples/#counter", 
            "text": "Source code  Demo  The basic example of using Carry with Reagent.", 
            "title": "Counter"
        }, 
        {
            "location": "/examples/#friend-list", 
            "text": "Source code  Demo  Inspired by this  problem  about dynamic search input.\nDemonstrates how to dispatch new signals from app controller and also features:   basic routing  model validation using  Schema  time traveling debugger  logging to console  unit tests", 
            "title": "Friend List"
        }, 
        {
            "location": "/examples/#todomvc", 
            "text": "Source code  Demo  See  todomvc.com .  Features:   routing using  Silk  local storage persistence  time traveling debugger  logging to console  model validation using  Schema  uses  Specter  for model updates", 
            "title": "TodoMVC"
        }, 
        {
            "location": "/examples/#counter-datascript", 
            "text": "Source code  Demo  Simplest example of using  DataScript  in-memory database for a model.", 
            "title": "Counter DataScript"
        }, 
        {
            "location": "/examples/#shopping-cart", 
            "text": "Source code  Demo  More advanced example of using  DataScript .\nInspired by  flux-comparison  problem.", 
            "title": "Shopping Cart"
        }, 
        {
            "location": "/examples/#composite-apps", 
            "text": "", 
            "title": "Composite Apps"
        }, 
        {
            "location": "/examples/#subapps", 
            "text": "Source code  Demo  In this project  counter app  and  friend list app  instances are \"statically\" added to the app spec.\nSeveral helper methods are extracted to make it easy to include any subapp at the time of app instantiation.", 
            "title": "Subapps"
        }, 
        {
            "location": "/examples/#counter-list", 
            "text": "Source code  Demo  In this example  counter app  instances are created and removed dynamically after app is started.", 
            "title": "Counter List"
        }, 
        {
            "location": "/api/", 
            "text": "It is a placeholder file, it will be replaced by API Reference docs generated by external tool.", 
            "title": "API Reference"
        }, 
        {
            "location": "/dev-guide/", 
            "text": "Documentation\n\n\nProject uses \nMkDocs\n with \nCinder\n theme and \nPlantUML\n to generate documentation static site.\n\nCodox\n is used to generate API reference.\nTasks are scripted using \nPyInvoke\n.\n\n\nServe site pages locally with automatic build (but it won't work for index page): \nmkdocs serve\n\n\nBuild only site pages: \ninv mkdocs\n\n\nBuild API reference into site folder: \ninv api\n\n\nBuild graphs into site folder: \ninv graphs\n\n\nBuild examples into site folder: \ninv examples\n\n\nBuild the whole site: \ninv site\n\n\nDeploying\n\n\nDeploy to Clojars: \nlein deploy clojars\n\n\nDeploy site to gh-pages branch: \nghp-import -p site", 
            "title": "Developer Guide"
        }, 
        {
            "location": "/dev-guide/#documentation", 
            "text": "Project uses  MkDocs  with  Cinder  theme and  PlantUML  to generate documentation static site. Codox  is used to generate API reference.\nTasks are scripted using  PyInvoke .  Serve site pages locally with automatic build (but it won't work for index page):  mkdocs serve  Build only site pages:  inv mkdocs  Build API reference into site folder:  inv api  Build graphs into site folder:  inv graphs  Build examples into site folder:  inv examples  Build the whole site:  inv site", 
            "title": "Documentation"
        }, 
        {
            "location": "/dev-guide/#deploying", 
            "text": "Deploy to Clojars:  lein deploy clojars  Deploy site to gh-pages branch:  ghp-import -p site", 
            "title": "Deploying"
        }
    ]
}